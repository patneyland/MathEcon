}
# plotting
plot(x~time1)
curve(0.1 * exp(x)/(1+0.1*(exp(x)-1.)), add=T)
legend("topleft", c("approximation", "analytical"),
pch=c(1,NA), lty=c(NA,1))
# time intervals: a sequence from zero to ten at 0.5 steps
time1 <- seq(0, 40, by = 0.1)
time2 <- seq(40, 55, by = 0.1)
# initial condition
r <- 0.05
s <- 0.1
w <- 50000
A <- (s*w)/r^2*exp(-r)
x0 <- 0.1
## The function to be integrated (right-hand expression of the derivative above)
f1 <- function(x){r*x + s*w}
f2 <- function(x){r*x - A}
## An empty R vector to store the results
x <- c()
## Store the initial condition in the first position of the vector
x[1] <- x0
# loop over time: approximate the function at each time step
for (i in 1:(length(time1)-1)){
x[i+1] = x[i] + 0.1 * f1(x[i])
}
for (i in 1:(length(time2)-1)){
x[i+1] = x[i] + 0.1 * f1(x[i])
}
# plotting
plot(x~time1)
plot(x~time2)
# time intervals: a sequence from zero to ten at 0.5 steps
time1 <- seq(0, 40, by = 0.1)
time2 <- seq(40, 55, by = 0.1)
# initial condition
r <- 0.05
s <- 0.1
w <- 50000
A <- (s*w)/r^2*exp(-r)
x0 <- 0.1
## The function to be integrated (right-hand expression of the derivative above)
f1 <- function(x){r*x + s*w}
f2 <- function(x){r*x - A}
## An empty R vector to store the results
x <- c()
## Store the initial condition in the first position of the vector
x[1] <- x0
# loop over time: approximate the function at each time step
for (i in 1:(length(time1)-1)){
x[i+1] = x[i] + 0.1 * f1(x[i])
}
# plotting
plot(x~time1)
plot(x~time2)
# time intervals: a sequence from zero to ten at 0.5 steps
time1 <- seq(0, 40, by = 0.1)
time2 <- seq(40, 55, by = 0.1)
# initial condition
r <- 0.05
s <- 0.1
w <- 50000
A <- (s*w)/r^2*exp(-r)
x0 <- 0.1
## The function to be integrated (right-hand expression of the derivative above)
f1 <- function(x){r*x + s*w}
f2 <- function(x){r*x - A}
## An empty R vector to store the results
x <- c()
## Store the initial condition in the first position of the vector
x[1] <- x0
# loop over time: approximate the function at each time step
for (i in 1:(length(time1)-1)){
x[i+1] = x[i] + 0.1 * f1(x[i])
}
# plotting
plot(x~time1)
curve(0.1 * exp(x)/(1+0.1*(exp(x)-1.)), add=T)
legend("topleft", c("approximation", "analytical"),
pch=c(1,NA), lty=c(NA,1))
# time intervals: a sequence from zero to ten at 0.5 steps
time1 <- seq(0, 40, by = 0.1)
time2 <- seq(40, 55, by = 0.1)
# initial condition
r <- 0.05
s <- 0.1
w <- 50000
A <- (s*w)/r^2*exp(-r)
x0 <- 0.1
## The function to be integrated (right-hand expression of the derivative above)
f1 <- function(x){r*x + s*w}
f2 <- function(x){r*x - A}
## An empty R vector to store the results
x <- c()
## Store the initial condition in the first position of the vector
x[1] <- x0
# loop over time: approximate the function at each time step
for (i in 1:(length(time1)-1)){
x[i+1] = x[i] + 0.1 * f1(x[i])
}
# plotting
plot(x~time1)
# time intervals: a sequence from zero to ten at 0.5 steps
time1 <- seq(0, 40, by = 0.1)
time2 <- seq(40, 55, by = 0.1)
# initial condition
r <- 0.05
s <- 0.1
w <- 50000
A <- (s*w)/r^2*exp(-r)
x0 <- 0.1
## The function to be integrated (right-hand expression of the derivative above)
f1 <- function(x){r*x + s*w}
f2 <- function(x){r*x - A}
## An empty R vector to store the results
x <- c()
## Store the initial condition in the first position of the vector
x[1] <- x0
# loop over time: approximate the function at each time step
for (i in 1:(length(time1)-1)){
x[i+1] = x[i] + 0.1 * f1(x[i])
}
# plotting
plot(x~time1)
curve(add=T)
# time intervals: a sequence from zero to ten at 0.5 steps
time1 <- seq(0, 40, by = 0.1)
time2 <- seq(40, 55, by = 0.1)
# initial condition
r <- 0.05
s <- 0.1
w <- 50000
A <- (s*w)/r^2*exp(-r)
x0 <- 0.1
## The function to be integrated (right-hand expression of the derivative above)
f1 <- function(x){r*x + s*w}
f2 <- function(x){r*x - A}
## An empty R vector to store the results
x <- c()
## Store the initial condition in the first position of the vector
x[1] <- x0
# loop over time: approximate the function at each time step
for (i in 1:(length(time1)-1)){
x[i+1] = x[i] + 0.1 * f1(x[i])
}
# plotting
plot(x~time1)
legend("topleft", c("approximation"),
pch=c(1,NA), lty=c(NA,1))
# time intervals: a sequence from zero to ten at 0.5 steps
time1 <- seq(0, 40, by = 0.1)
time2 <- seq(40, 55, by = 0.1)
# initial condition
r <- 0.05
s <- 0.1
w <- 50000
A <- (s*w)/r^2*exp(-r)
x0 <- 0.1
## The function to be integrated (right-hand expression of the derivative above)
f1 <- function(x){r*x + s*w}
f2 <- function(x){r*x - A}
## An empty R vector to store the results
x <- c()
## Store the initial condition in the first position of the vector
x[1] <- x0
# loop over time: approximate the function at each time step
for (i in 1:(length(time1)-1)){
x[i+1] = x[i] + 1 * f1(x[i])
}
# plotting
plot(x~time1)
legend("topleft", c("approximation"),
pch=c(1,NA), lty=c(NA,1))
# time intervals: a sequence from zero to ten at 0.5 steps
time1 <- seq(0, 40, by = 0.1)
time2 <- seq(40, 55, by = 0.1)
# initial condition
r <- 0.05
s <- 0.1
w <- 50000
A <- (s*w)/r^2*exp(-r)
x0 <- 0.1
## The function to be integrated (right-hand expression of the derivative above)
f1 <- function(x){r*x + s*w}
f2 <- function(x){r*x - A}
## An empty R vector to store the results
x <- c()
## Store the initial condition in the first position of the vector
x[1] <- x0
# loop over time: approximate the function at each time step
for (i in 1:(length(time1)-1)){
x[i+1] = x[i] + 0.1 * f1(x[i])
}
# plotting
plot(x~time1)
legend("topleft", c("approximation"),
pch=c(1,NA), lty=c(NA,1))
# time intervals: a sequence from zero to ten at 0.5 steps
time <- seq(0, 55, by = 0.1)
time2 <- seq(40, 55, by = 0.1)
# initial condition
r <- 0.05
s <- 0.1
w <- 50000
A <- (s*w)/r^2*exp(-r)
x0 <- 0.1
## The function to be integrated (right-hand expression of the derivative above)
f1 <- function(x){
if(time<=40){r*x + s*w}
else {r*x - A}
}
## An empty R vector to store the results
x <- c()
## Store the initial condition in the first position of the vector
x[1] <- x0
# loop over time: approximate the function at each time step
for (i in 1:(length(time)-1)){
x[i+1] = x[i] + 0.1 * f1(x[i])
}
# plotting
plot(x~time)
legend("topleft", c("approximation"),
pch=c(1,NA), lty=c(NA,1))
# time intervals: a sequence from zero to ten at 0.5 steps
time <- seq(0, 55, by = 0.1)
time2 <- seq(40, 55, by = 0.1)
# initial condition
r <- 0.05
s <- 0.1
w <- 50000
A <- (s*w)/r^2*exp(-r)
x0 <- 0.1
## The function to be integrated (right-hand expression of the derivative above)
f1 <- function(x){
if(time<=40){r*x + s*w}
else {r*x - A}
}
## An empty R vector to store the results
x <- c()
## Store the initial condition in the first position of the vector
x[1] <- x0
# loop over time: approximate the function at each time step
for (i in 1:(length(time)-1)){
x[i+1] = x[i] + 0.1 * f1(x[i])
}
# plotting
plot(x~time)
legend("topleft", c("approximation"),
pch=c(1,NA), lty=c(NA,1))
# time intervals: a sequence from zero to ten at 0.5 steps
time <- seq(0, 55, by = 0.1)
time2 <- seq(40, 55, by = 0.1)
# initial condition
r <- 0.05
s <- 0.1
w <- 50000
A <- (s*w)/r^2*exp(-r)
x0 <- 0
## The function to be integrated (right-hand expression of the derivative above)
f1 <- function(x){
if(time<=40){r*x + s*w}
else {r*x - A}
}
## An empty R vector to store the results
x <- c()
## Store the initial condition in the first position of the vector
x[1] <- x0
# loop over time: approximate the function at each time step
for (i in 1:(length(time)-1)){
x[i+1] = x[i] + 0.1 * f1(x[i])
}
# plotting
plot(x~time)
legend("topleft", c("approximation"),
pch=c(1,NA), lty=c(NA,1))
# time intervals: a sequence from zero to ten at 0.5 steps
time <- seq(0, 55, by = 0.1)
time2 <- seq(40, 55, by = 0.1)
# initial condition
r <- 0.05
s <- 0.1
w <- 50000
A <- (s*w)/r^2*exp(-r)
x0 <- 3
## The function to be integrated (right-hand expression of the derivative above)
f1 <- function(x){
if(time<=40){r*x + s*w}
else {r*x - A}
}
## An empty R vector to store the results
x <- c()
## Store the initial condition in the first position of the vector
x[1] <- x0
# loop over time: approximate the function at each time step
for (i in 1:(length(time)-1)){
x[i+1] = x[i] + 0.1 * f1(x[i])
}
# plotting
plot(x~time)
legend("topleft", c("approximation"),
pch=c(1,NA), lty=c(NA,1))
knitr::opts_chunk$set(echo = TRUE)
# time intervals: a sequence from zero to ten at 0.5 steps
time <- seq(0, 55, by = 0.1)
# initial condition
r <- 0.05
s <- 0.1
w <- 50000
A <- (s*w)/exp(-r)
x0 <- 0
## The function to be integrated (right-hand expression of the derivative above)
f1 <- function(x){
if(time<=40){r*x + s*w}
else {r*x - A}
}
## An empty R vector to store the results
x <- c()
## Store the initial condition in the first position of the vector
x[1] <- x0
# loop over time: approximate the function at each time step
for (i in 1:(length(time)-1)){
x[i+1] = x[i] + 0.5 * f1(x[i])
}
# plotting
plot(x~time)
legend("topleft", c("approximation"),
pch=c(1,NA), lty=c(NA,1))
knitr::opts_chunk$set(comment = NA)
library(tidyverse)
library(wooldridge)
library(stargazer)
df <- filter(k401ksubs, fsize == 1)
length(df$fsize)
model5_2 <- lm(nettfa ~ inc + age, data = df)
stargazer(model5_2, type = "text")
model5_5 <- lm(nettfa ~ inc, data = df)
model5_5 <- lm(nettfa ~ inc, data = df)
stargazer(model5_5, type = "text")
model5_5 <- lm(nettfa ~ inc, data = df)
stargazer(model5_5, type = "text")
model6_1 <- lm(log(psoda) ~ prpblck + log(income) + prppov, data = discrim)
stargazer(model6_1, type = "text")
cor(discrim$lincome, discrim$prppov)
discrim %>% cor(lincome, prppov)
cor(discrim$lincome, discrim$prppov, na.rm = TRUE)
cor(discrim$lincome, discrim$prppov)
data(discrim, na.rm = TRUE)) %>% cor(discrim$lincome, discrim$prppov)
data(discrim, na.rm = TRUE) %>% cor(discrim$lincome, discrim$prppov)
data(discrim, na.rm = TRUE) %>% cor(discrim$lincome, discrim$prppov)
df1 <- na.omit(discrim)
df1 <- na.omit(discrim)
cor(df$lincome, df$prppov)
df1 <- na.omit(discrim)
cor(df$lincome, df$prppov)
cor(df1$lincome, df1$prppov)
cor(log(df1$income, df1$prppov))
cor(log(df1$income), df1$prppov)
cor(df1$lincome, df1$prppov)
cor(log(df1$income), df1$prppov)
summary(model6_1)
library(car)
linearHypothesis(model6_1, c("prpblck = 0", "prppov = 0"))
model6_3 <- lm(log(psoda) ~ prpblck + (prpblck+prppov) + log(income), data = discrim)
stargazer(model6_1, model6_3, type = "text")
reg <- lm(lwage~jc+univ+exper, twoyear)
# H0: b1=b2   H1: b1 != b2
df          <- mutate(totcoll= jc+univ, twoyear)
reg_new     <- lm(lwage~jc+totcoll+exper, df)
stargazer(reg, reg_new, type="text")
model6_4 <- lm(log(psoda) ~ prpblck + log(income) +
prppov + log(hseval), data = discrim)
stargazer(model6_4, type = "text")
summary(model6_4)
stargazer(model6_4, type = "text")
help(discrim)
linearHypothesis(model6_4, c("prpblck-prppov=0"))
linearHypothesis(model6_1, c("prpblck = 0", "prppov = 0"))
linearHypothesis(reg, c("feduc-meduc=0"))
# alternatively, using theta method:
reg_new   <- lm(log(wage)~ IQ + educ + exper + age + feduc + I(feduc+meduc), wage2)
# Prof. Pedram Jahangiry
# Chapter 4: MRM inference
library(wooldridge)
library(stargazer)
library(dplyr)
# Example 4-8
MRM <- lm(log(rd)~ log(sales)+ profmarg, rdchem)
summary(MRM)
stargazer(MRM, type = "text")
# finding critical values
df    <- nobs(MRM) - 2-1
alpha <- 0.05
# let's do a two-tailed test
qt(1- alpha/2 , df)
# Look at t_stat
summary(MRM)$coefficients[ ,'t value' ]
# Confidence Interval
confint(MRM, level =  1-alpha)
# let's check if H1: b2>0 . say alpha =0.1
# from R out put the t= 1.694
t <- 1.694
qt(0.90, 29)
# because t > c , we reject the null at 10% significance level.
# what is the p-value for the one tailed test?
# method 1:
1-pt(1.694,29)
# method 2: it is equal to the half of p-value for 2 tailed test which was 0.101
0.101/2
##############################################################################
# Single linear combination (LC) of the parameters:
reg <- lm(lwage~jc+univ+exper, twoyear)
summary(reg)
# H0: b1=b2   H1: b1 != b2
df          <- mutate(totcoll= jc+univ, twoyear)
reg_new     <- lm(lwage~jc+totcoll+exper, df)
summary(reg_new)
stargazer(reg, reg_new, type="text")
# what if we want to test H1: b1 < b2?
t <- -1.468
qt(0.05, 6759 )
# what is the p-value for one tailed test
pt(-1.468, 6759)
# so the p-value is 7%
# Constructing 95% confidence interval
confint(reg_new, level =  0.95)
#-------------------------------------------------------
# H0: b2=2*b1   H1: b2 != 2*b1
df          <- mutate(collcomb = 2*univ + jc, twoyear)
reg_new1    <- lm(lwage~collcomb+univ+exper, df)
# another way of doing this:
reg_new2   <- lm(lwage~ I(2*univ+jc)+univ+exper, df)
summary(reg_new1)
summary(reg_new2)
stargazer(reg, reg_new, reg_new1, reg_new2, type="text")
#------------------------------------------------------------------------------------
# later in chapter 6 we will see that we can use the following function as well.
library(car)
linearHypothesis(reg, c("jc-univ=0"))
# exercise: in the following regression, test the hypothesis that the father education has a
# higher impact of your future salary than mothers education?
reg <- lm(log(wage) ~ IQ + educ + exper + age + feduc + meduc, wage2)
summary(reg)
linearHypothesis(reg, c("feduc-meduc=0"))
# so the p-value is 0.85/2 = 42.5 and we fail to reject the null that feduc > meduc
# alternatively, using theta method:
reg_new   <- lm(log(wage)~ IQ + educ + exper + age + feduc + I(feduc+meduc), wage2)
summary(reg_new)
# the one tailed p-value is the same 0.85/2 = 42.5.
linearHypothesis(reg, c("feduc-meduc=0"))
df <- mutate()
#df <- mutate()
model6_3 <- lm(log(psoda) ~ prpblck + I(prpblck+prppov) + log(income), data = discrim)
stargazer(model6_1, model6_3, type = "text")
linearHypothesis(model5_2, "age=1")
knitr::opts_chunk$set(echo = TRUE)
r <- 0.035
w <- 75000
s <- 0.1
T <- 40
Tbar <- 55
dt <- 0.01
A <- 40000
time <- seq(0, T, by = dt)
ka <- if (time<T) {
c(0, (lag(ka)*r + w*s)*dt)
}     else {
c((lag(ka)*r-A)*dt)
}
r <- 0.035
w <- 75000
s <- 0.1
T <- 40
Tbar <- 55
dt <- 0.01
A <- 40000
time <- seq(0, T, by = dt)
ka0 <- 0
ka <- if (time<T) {
c(0, (lag(ka0)*r + w*s)*dt)
}     else {
c((lag(ka0)*r-A)*dt)
}
df <- data.frame(time)
head(df)
c((r-A)*dt)
df <- data.frame(time, ka)
x+1
for(x in time) {
x+1
}
df <- data.frame(time, time_plus)
time_plus <- for(x in time) {
x+1
}
df <- data.frame(time, time_plus)
head(df)
time_plus <- for(x in time) {
print
}
time_plus
time_plus <- for(x in time) {
print(x)
}
time_plus <- for(x in time) {
print(c(x))
}
install.packages(bvpSolve)
install.packages("bvpSolve")
help(bvpSolve)
library(bvpSolve)
help("bvpSolve")
example(bvpshoot)
